####################################################
# LSrouter.py
# Name:
# HUID:
#####################################################

from router import Router
from packet import Packet
import json
import heapq

class LSA:
    def __init__(self, advertising_router, seq_num):
        self.advertising_router = advertising_router
        self.seq_num = seq_num
        # Key: router_addr | Value: (cost, port)
        self.links = {}
    
    def to_json(self):
        return json.dumps({
            "advertising_router": self.advertising_router,
            "seq_num": self.seq_num,
            "links": self.links
        })

class LSrouter(Router):
    """Link state routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """    
    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here

        # Key: advertising_router_addr | Value: seq_num
        self.seq_lsa = {}

        # Key: advertising_router_addr | Value: links connected with advertising router
        self.link_state_db = {}
        self.link_state_db[self.addr] = []

        self.lsa = LSA(self.addr, 0)

        # Key: router_addr | Value: port
        self.routing_table = {}
        
    def config_routing_table(self):
        pq = []
        heapq.heappush(pq, (0, (self.addr, self.addr)))
        visited = set()
        parent = {}
        dist = {}
        while pq:
            currentLink = heapq.heappop(pq)
            curr_addr = currentLink[1][0]
            curr_cost = currentLink[0]
            curr_parrent = currentLink[1][1]
            if curr_addr not in visited:
                visited.add(curr_addr)
                dist[curr_addr] = curr_cost
                parent[curr_addr] = curr_parrent
                if (curr_addr in self.link_state_db):
                    for edge in self.link_state_db[curr_addr]:
                        heapq.heappush(pq, (curr_cost + edge[1], (edge[0], curr_addr)))

        self.routing_table = {}
        for router_addr in visited:
            if router_addr == self.addr:
                continue
            next_hop = router_addr
            while parent[next_hop] != self.addr:
                next_hop = parent[next_hop]
            if next_hop in self.lsa.links:
                self.routing_table[router_addr] = self.lsa.links[next_hop][1]

    def convert_json_to_lsa(self, str):
        data = json.loads(str)
        lsa = LSA(
            data["advertising_router"],
            data["seq_num"],
        )
        lsa.links = data["links"]
        return lsa
    
    def broadcast(self, packet, sender_router_addr):
        for router_addr, link in self.lsa.links.items():  
            if not router_addr.isupper() or router_addr == sender_router_addr:
                continue
            port = link[1]
            if packet is not None:
                self.send(link[1], packet)
                continue
            packet = Packet(Packet.ROUTING, self.addr, router_addr, self.lsa.to_json())
            self.send(port, packet)

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)

            if (packet.dst_addr in self.routing_table):
                self.send(self.routing_table[packet.dst_addr], packet)
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors

            recv_lsa = self.convert_json_to_lsa(packet.content)
            if (recv_lsa.advertising_router in self.seq_lsa and recv_lsa.seq_num <= self.seq_lsa[recv_lsa.advertising_router]):
                return
            self.seq_lsa[recv_lsa.advertising_router] = recv_lsa.seq_num

            self.link_state_db[recv_lsa.advertising_router] = []

            for router_id, links in recv_lsa.links.items():
                self.link_state_db[recv_lsa.advertising_router].append((router_id, links[0], links[1]))
            self.broadcast(packet, packet.src_addr)
            self.config_routing_table()

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors

        self.lsa.links[endpoint] = [cost, port]
        self.link_state_db[self.addr].append((endpoint, cost, port))
        self.broadcast(None, None)
        self.config_routing_table()
        self.lsa.seq_num = self.lsa.seq_num + 1

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors

        for router_addr, link in self.lsa.links.items():
            if link[1] == port:
                self.link_state_db[self.addr].remove((router_addr, link[0], port))
                del self.lsa.links[router_addr]
                break
        self.config_routing_table()
        self.broadcast(None, None)
        self.lsa.seq_num = self.lsa.seq_num + 1

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the link state of this router to all neighbors
            self.broadcast(None, None)
            self.lsa.seq_num = self.lsa.seq_num + 1

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        # 
        self.config_routing_table()
        return f"Routing Table: \n{self.routing_table},\nLSA: \n{self.lsa.to_json()}"
